{"pageProps":{"postData":{"contentHtml":"<p>線形代数ライブラリを作ろうと色々とプログラムを書いていたわけですが、なんとなくで転置行列をどう簡単に求めるかということを考え始めました。その時に思いついた転置行列の求め方を共有します。</p>\n<h2>一般解ぽいやつ(個人の見解)</h2>\n<p>まずは一般に使われそうな方法を考えてみました。</p>\n<p>入力行列は<em>3x2</em>の行列として、求める転置行列は<em>2x3</em>とします。対応するインデックスの関係がわかりやすいように数値を設定してみます。</p>\n<pre><code class=\"hljs language-python\">A = [\n    [<span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">12</span>],\n    [<span class=\"hljs-number\">21</span>, <span class=\"hljs-number\">22</span>],\n    [<span class=\"hljs-number\">31</span>, <span class=\"hljs-number\">32</span>]\n]\n\nAt = []\nj = <span class=\"hljs-number\">0</span>\n<span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(A[j])):\n    row = []\n    <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(A)):\n        row.append(A[j][i])\n    At.append(row)\n    \n<span class=\"hljs-built_in\">print</span>(At)\n</code></pre>\n<p>これで動くはず...オーソドックスか知らんけど、二重ループ回すのが一般的な思考だと思ったので、これを一般解として提示しました。</p>\n<p>ちなみに得られる出力はこちらです。</p>\n<pre><code class=\"hljs language-bash\">[[11, 21, 31], [12, 22, 32]]\n</code></pre>\n<p>多分大丈夫そう。</p>\n<h2>一般解ぽいやつを内包表記してみた</h2>\n<p>さきに示した一般解っぽいやつを内包表記を用いて書いてみます。</p>\n<pre><code class=\"hljs language-python\">A = [\n    [<span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">12</span>],\n    [<span class=\"hljs-number\">21</span>, <span class=\"hljs-number\">22</span>],\n    [<span class=\"hljs-number\">31</span>, <span class=\"hljs-number\">32</span>]\n]\n\nj = <span class=\"hljs-number\">0</span>\nAt = [\n    [A[j][i] <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(A))]\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(A[j]))\n]\n<span class=\"hljs-built_in\">print</span>(At)\n</code></pre>\n<p>これも同様に同じ出力が得られます。</p>\n<pre><code class=\"hljs language-bash\">[[11, 21, 31], [12, 22, 32]]\n</code></pre>\n<h2>【本題】zipと展開の合わせ技</h2>\n<p>さて、本題です。僕が思いついた手法は以下になります。</p>\n<ol>\n<li>A(入力行列)を展開して、行列から列ごとに展開</li>\n<li>zip()を用いて統合</li>\n<li>内包表記にて転置行列を生成</li>\n</ol>\n<p>こんな流れになります。言葉で言っても難しいので、コードをみてみます。</p>\n<pre><code class=\"hljs language-python\">A = [\n    [<span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">12</span>],\n    [<span class=\"hljs-number\">21</span>, <span class=\"hljs-number\">22</span>],\n    [<span class=\"hljs-number\">31</span>, <span class=\"hljs-number\">32</span>]\n]\n\nAt = [\n    <span class=\"hljs-built_in\">list</span>(row) <span class=\"hljs-keyword\">for</span> row <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">zip</span>(*A)\n]\n<span class=\"hljs-built_in\">print</span>(At)\n</code></pre>\n<p>これだけです。</p>\n<p>ただ、注意すべき点が一つだけあります。</p>\n<p>**list()**としているところです。それはなぜかというと、zipで統合された物は<em>tuple</em>で帰ってきます。</p>\n<p>内包表記において、listをとると次のような出力になります。</p>\n<pre><code class=\"hljs language-bash\">[(11, 21, 31), (12, 22, 32)]\n</code></pre>\n<p><em>tuple</em>で返ってきても良いスクリプトであればそのままでも良いと思いますが、<em>tuple</em>だとイミュータブルなデータになってしまうので、大抵の場合**list()**でlist型に直してあげた方が良いことが多い気がします。</p>\n<p>処理速度は測っていませんが、おそらく大きなサイズの行列の入力の時は高速に動くと思います(多分)</p>\n<p>興味ある人は処理速度を計測してみてください。それでは、簡単な転置行列を求める方法の提案でした。(Pythonに限る)</p>","Title":"簡単に転置行列求めてみた","Date":"2020-10-12","Category":"Python","Tags":"Python","Authors":"ゆうぼう","Slug":"py-trans-matrix","Thumbnail":"/images/thumbnails/python.jpg","Description":"線形代数ライブラリを作ろうと色々とプログラムを書いていたわけですが、なんとなくで転置行列をどう簡単に求めるかということを考え始めました。その時に思いついた転置行列の求め方を共有します。","Published":true},"categories":["論文","Web","JavaScript","Competition","Cloud","Python","Linux","ML","Go","SQL"],"tags":["Apache","Appium","ASR","atmaCup","AWS","brew","CentOS7","CentOS8","Colab","COMET","commonsense","conda","Contrasive Learning","Contrastive Learning","CSS","Demo","Dialogue Structure Learning","dialogue system","DST","Emotion Recognition","empathetic dialogue system","encyclopedic","Error Correction","ESPNet","ffmpeg","Flask","Gating Mechanism","Go","Google Colaboratory","Heroku","Highway Transformer","HTML","humor detection","Intent Classification","Internet-Augmented","JavaScript","JSON","Kaggle","KC-Net","knowledge-base","Knowledge-Intensive NLP","laughter","Linux","LLM","Mac","make","map","MeCab","mental health","mental state knowledge","mentalisation","MentalRoBERTa","Merging Models","ML","Model Editing","Model Patching","MT","Multi-Hop Transformer","multi-modal","MySQL","NLG","NLI","NLP","Node","node.js","npm","Overleaf","Pandas","persona","PLMKE","Poetry","Prompt-Tuning","Python","Pytorch","pytorch-lightning","Scikit-learn","Selenium","Self-Dependency-Units (SDU)","shared laughter","SISR","SLU","Speech Disfluency","subprocess","Super-Resolution","survey","tensorflow","Tkinter","Transfer Learning","transformer","Weight Interpolation","zsh","オブジェクト指向","デコレータ","データ分析","特殊メソッド","聞き手反応","論文執筆","超解像"]},"__N_SSG":true}
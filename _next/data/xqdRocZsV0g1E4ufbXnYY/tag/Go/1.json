{"pageProps":{"TaggedPostData":[{"contentHtml":"<p>Goは静的型付言語でありながら、どうやら型を推論できるらしいですね。公式チュートリアルをみて知りましたが。ここでいくつか型を試してみたので、その実験結果を報告していきます。</p>\n<h2>静的型付らしい変数宣言</h2>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">var</span> i, j <span class=\"hljs-type\">int</span> = <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>\n</code></pre>\n<p>よくやる印象を持つのはこれですかね。(Cの方がGoより馴染んでいる状態だからかもしれないけど)</p>\n<p>とりあえず、<em>var variable type</em>で型宣言ができるという仕様なわけですね。</p>\n<h2>型推論(Goチュートリアルより)</h2>\n<p>Goのチュートリアルの中に「<a href=\"https://tour.golang.org/basics/14\">型推論(type inferece)</a>」というセクションがありました。そこからコードを引用させていただきます。</p>\n<p>そこで紹介されていたコードがこちらです。</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\"fmt\"</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\tv := <span class=\"hljs-number\">42</span> <span class=\"hljs-comment\">// change me!</span>\n\tfmt.Printf(<span class=\"hljs-string\">\"v is of type %T\\n\"</span>, v)\n}\n\n</code></pre>\n<p>これで得られる結果がこちらです。</p>\n<pre><code class=\"hljs language-bash\">v is of <span class=\"hljs-built_in\">type</span> int\n</code></pre>\n<p>型宣言は明示的には行っていませんが、int型であることを推論し認識したようです。</p>\n<p>それでは、次のセクションでは他に推論できた型を紹介していきます。</p>\n<h2>推論できた型集</h2>\n<p>ソースコードにより紹介していきます。</p>\n<p>コード自体は先ほどの公式チュートリアルより引用させていただいたコードが元になっています。(Go使いではないので、慣習的によくない表現があれば教えていただきたいです。)</p>\n<p>コードがこちら。</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\"fmt\"</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>  {\n\ti := <span class=\"hljs-number\">3</span>\n\ti32 := <span class=\"hljs-string\">'3'</span>\n\tf := <span class=\"hljs-number\">3.14</span>\n\tj := <span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">1i</span>\n\tb := <span class=\"hljs-literal\">false</span>\n\ts := <span class=\"hljs-string\">\"string\"</span>\n\tfmt.Printf(<span class=\"hljs-string\">\"i is of type %T\\\\n\"</span>, i)\n\tfmt.Printf(<span class=\"hljs-string\">\"i32 is of type %T\\\\n\"</span>, i32)\n\tfmt.Printf(<span class=\"hljs-string\">\"f is of type %T\\\\n\"</span>, f)\n\tfmt.Printf(<span class=\"hljs-string\">\"j is of type %T\\\\n\"</span>, j)\n\tfmt.Printf(<span class=\"hljs-string\">\"b is of type %T\\\\n\"</span>, b)\n\tfmt.Printf(<span class=\"hljs-string\">\"s is of type %T\\\\n\"</span>, s)\n}\n</code></pre>\n<p>上記のコードより得られる結果がこちらです。</p>\n<pre><code class=\"hljs language-bash\">i is of <span class=\"hljs-built_in\">type</span> int\ni32 is of <span class=\"hljs-built_in\">type</span> int32\nf is of <span class=\"hljs-built_in\">type</span> float64\nj is of <span class=\"hljs-built_in\">type</span> complex128\nb is of <span class=\"hljs-built_in\">type</span> bool\ns is of <span class=\"hljs-built_in\">type</span> string\n</code></pre>\n<p>個人的に詰まった？理解に苦しむのは<em>int32</em>ですかね。「''」と「\"\"」が違った意味合いを持つのはPythonユーザからすると少しつまりますね。しかし、経験してしまえば覚えるので大丈夫ですね。</p>\n<p>とりあえず、Go初めて勉強3日間の僕が観測できた型推論はこれらになります。</p>\n<ul>\n<li>int</li>\n<li>int32</li>\n<li>float64</li>\n<li>complex128</li>\n<li>bool</li>\n<li>string</li>\n</ul>\n<p>他にもあったら教えていただきたいです。(Gopherの皆さんよろしくお願いします)</p>\n<p>なかなか使いやすい言語と言った所感なので、これからGoの勉強とこのブログによるアウトプットをゆっくりやって行こうかなと思います。(他の開発が最優先なので)</p>\n<p>今回は「<strong>Goの型の推論</strong>」についてお話ししました〜。それでは。</p>\n<h2>追記</h2>\n<p>uint8(unsigned int8)もできるみたいです。情報提供ありがとうございます。</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>  {\n\tu := []<span class=\"hljs-type\">byte</span>{<span class=\"hljs-string\">'3'</span>}\n\tfmt.Printf(<span class=\"hljs-string\">\"u is of type %T\\\\n\"</span>, u)\n}\n</code></pre>\n<p>出力は以下になります。</p>\n<pre><code class=\"hljs language-bash\">u is of <span class=\"hljs-built_in\">type</span> []uint8\n</code></pre>","Title":"Goはどうやら型を推論できるらしい話","Date":"2020-10-10","Category":"Go","Tags":"Go","Authors":"ゆうぼう","Slug":"go-type-inference","Thumbnail":"/images/thumbnails/gopher.jpg","Description":"Goは静的型付言語でありながら、どうやら型を推論できるらしいですね。公式チュートリアルをみて知りましたが。ここでいくつか型を試してみたので、その実験結果を報告していきます。","Published":true},{"contentHtml":"<p>環境構築がいつも面倒くさくて、実際にローカルで開発を始めるまでに毎回時間がかかるので新しい言語を始める時躊躇われることが多いです。そう思いつつもGoを始めてみたところ、かなり環境構築が楽でした。その時の話を少ししていきます。</p>\n<p>インストールをしていく際は、こちらのサイトを参照されたい。</p>\n<p><a href=\"https://golang.org/doc/install\">https://golang.org/doc/install</a></p>\n<h2>インストーラのダウンロード</h2>\n<p>まずは、上に示していた<a href=\"https://golang.org/doc/install\">https://golang.org/doc/install</a>にアクセスします。</p>\n<p>すると、最上部にダウンロードの手順が示されており以下のようになっています。</p>\n<ol>\n<li>Go donwload.</li>\n<li>Go install.</li>\n<li>Go code.</li>\n</ol>\n<p>最初の手順としてインストーラのダウンロードを行います。</p>\n<p><img src=\"/images/article/go-download.png\" alt=\"Goのdownload\"></p>\n<p>上の画像をのように、画面は開いているPCのOSに合わせて適したインストーラがダウンロードできるようになっています。</p>\n<p>私の場合は、Macから触っているのでMac用ダウンロードになっています。</p>\n<p>こちらをクリックしてダウンロードします。</p>\n<h2>インストールする</h2>\n<p>続いて、インストールをします。先ほどダウンロードしたものがインストーラなのでそれを立ち上げてインストールを開始します。</p>\n<p>インストール画面が出たら、特に何も設定せずに、次へと進んでいって大丈夫です。</p>\n<p><strong>PATH</strong>は勝手に通してくれるみたいです。</p>\n<p>ちなみに、公式にはこのようなことが説明に書いてあります。</p>\n<p>Linux</p>\n<p><img src=\"/images/article/go-install-linux.png\" alt=\"Go install for linux\"></p>\n<p>Mac</p>\n<p><img src=\"/images/article/go-install-mac.png\" alt=\"Go install for mac\"></p>\n<p>Windows</p>\n<p><img src=\"/images/article/go-install-windows.png\" alt=\"Go install for windows\"></p>\n<p>とりあえず、Macでしかインストールを試していないのでMacを前提にこの記事を進めさせていただきますね。</p>\n<p>インストールできたら、ターミナルを開きます。（or 開きなおします）</p>\n<p>そこで、<em>go version</em>とコマンドを打ってみましょう。</p>\n<pre><code class=\"hljs language-bash\">$ go version\n</code></pre>\n<p>結果は以下が得られるはずです(10/5現在)</p>\n<pre><code class=\"hljs language-bash\">$ go version\ngo version go1.15.2 darwin/amd64\n</code></pre>\n<h2>go versionがエラーで表示されない</h2>\n<p>PATHが通っていないことが考えられます。</p>\n<p>そこで解決策を二つ提示します。</p>\n<ol>\n<li>ターミナルを開き直す</li>\n<li>PATHを明示的に通す</li>\n</ol>\n<h2>#ターミナルを開き直す</h2>\n<p>ターミナルを開きなおして、インストールの設定が完了した状態にしましょう。</p>\n<p>これでもダメなら次へ行きます。</p>\n<h2>#PATHを明示的に通す</h2>\n<p>一応デフォルトでPATHが通るはずですが、通らないこともあると思うので、<strong>明示的に</strong>PATHを通してみます。</p>\n<p>ターミナルでPATHを通しましょう。</p>\n<pre><code class=\"hljs language-bash\">$ <span class=\"hljs-built_in\">export</span> PATH=<span class=\"hljs-variable\">$PATH</span>:/usr/local/go/bin\n</code></pre>\n<p>とりあえず、これでPATHが通ればうまくいくはずです。</p>\n<p>......</p>\n<p>これでもダメならインストールしなおせばうまくいくんじゃないかな...(暴論)</p>\n<h2>まとめ</h2>\n<p>これでGoのインストールが完了したはずです。</p>\n<p>インストール自体に時間が割かれることが多い印象ですが、この言語はインストールも早く、かなり高速で言語をローカルで触る環境が整うといった印象でした。</p>\n<p>書き方もかなり使い易くて、静的型付言語の煩わしさを取っ払ったような感じがしました。(感じがしただけで実際まだよくわからないww)</p>\n<p>ちょっと面白そうな感じだったので、深掘りして学んでみてWeb APIでもあとで作ってみようかなと思います。</p>\n<p>それではGoのインストールはここまでです。</p>","Title":"Goのインストールが楽すぎた話","Date":"2020-10-05","Category":"Go","Tags":"Go","Authors":"ゆうぼう","Slug":"go-install","Thumbnail":"/images/thumbnails/gopher.jpg","Description":"環境構築がいつも面倒くさくて、実際にローカルで開発を始めるまでに毎回時間がかかるので新しい言語を始める時躊躇われることが多いです。そう思いつつもGoを始めてみたところ、かなり環境構築が楽でした。その時の話を少ししていきます。","Published":true},{"contentHtml":"<p><strong>GoでHello, world!</strong></p>\n<p>今回はただそれだけをしたいと思いますw</p>\n<h2>チュートリアルによくあるHello, world!</h2>\n<p>hello.goというファイルに書き書きしていきます。</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\"fmt\"</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    fmt.Printf(<span class=\"hljs-string\">\"Hello, world!\"</span>)\n}\n</code></pre>\n<p>そしてターミナルから実行します。</p>\n<pre><code class=\"hljs language-bash\">$ go run hello.go\nHello, world!\n</code></pre>\n<p>これがよくある標準出力させるプログラムになります。</p>\n<p>構造は至ってシンプルで、<em>fmt</em>をインポートして、そのメソッドである<em>Printf</em>で出力するという感じです。</p>\n<p>他にも<em>fmt.Println</em>や<em>fmt.Print</em>といった物もあるようですが。</p>\n<h2>ビルトインにprintln</h2>\n<p>ビルトインを漁ってみるとなんだか、<em>println</em>というビルトイン関数を発見!!</p>\n<p>これで試しにハロワしてみました。<br>\nこちらも<em>hello.go</em>に書いていきましょう。</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>  {\n    <span class=\"hljs-built_in\">println</span>(<span class=\"hljs-string\">\"Hello, world!\"</span>)\n}\n</code></pre>\n<p>このコードもターミナルから同様に実行していきます。</p>\n<pre><code class=\"hljs language-bash\">$ go run hello.go\nHello, world!\n</code></pre>\n<p>同じような結果が得られました。</p>\n<p><em>fmt.Println</em>をするなら、ビルトイン関数の<em>println</em>で代用できそうですね。</p>\n<p>一応ブートストラッピングとかデバッグに有用性を示せるみたいです。</p>\n<p>簡単にデバッグをするときに、このビルトイン関数を使えば良いでしょう。チュートリアルでもfmtをインポートして使っているので、推奨はfmtなんですかね。</p>\n<p>その辺はもう少し知見をつけてからにしようと思います。</p>\n<p>とりあえずはこれだけでHello, world!はできそうです。</p>","Title":"GoでHello, world!","Date":"2020-10-05","Category":"Go","Tags":"Go","Authors":"ゆうぼう","Slug":"go-hello","Thumbnail":"/images/thumbnails/gopher.jpg","Description":"GoでHello, world!","Published":true}],"tag":"Go","categories":["論文","Web","JavaScript","Competition","Cloud","Linux","Python","ML","Go","SQL"],"tags":["Apache","Appium","atmaCup","AWS","CentOS7","CentOS8","Colab","COMET","commonsense","conda","Contrasive Learning","Contrastive Learning","CSS","Dialogue Structure Learning","dialogue system","DST","empathetic dialogue system","encyclopedic","ESPNet","ffmpeg","Flask","Gating Mechanism","Go","Google Colaboratory","Heroku","Highway Transformer","HTML","humor detection","Internet-Augmented","JavaScript","JSON","Kaggle","KC-Net","knowledge-base","Knowledge-Intensive NLP","laughter","Linux","Mac","make","map","MeCab","mental health","mental state knowledge","mentalisation","MentalRoBERTa","ML","MT","Multi-Hop Transformer","multi-modal","MySQL","NLG","NLI","NLP","Node","node.js","npm","Pandas","persona","PLMKE","Poetry","Prompt-Tuning","Python","Pytorch","pytorch-lightning","Scikit-learn","Selenium","Self-Dependency-Units (SDU)","shared laughter","SISR","subprocess","Super-Resolution","survey","tensorflow","Tkinter","transformer","zsh","オブジェクト指向","デコレータ","データ分析","特殊メソッド","聞き手反応","超解像"],"pages":1,"page":1},"__N_SSG":true}
{"pageProps":{"postData":{"contentHtml":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/katex@0.15.0/dist/katex.min.css\">\n</head>\n<body>\n<p>一次元配列のソートは簡単だし、困るのは多次元配列です。しかも、よく記事になっているのは多次元配列の要素中の配列の数字に対してソートをよくやるんですよね〜。文字列でソートはどーやるん？と思って解決した方法を共有します。(数値と全く方法は変わらないんですけどねww)</p>\n<h2>やりたいこと</h2>\n<p>まずはやりたいことを整理します。</p>\n<p>ソート対象リストを下のように定めます。</p>\n<pre><code class=\"hljs language-js\">arr = [\n    [<span class=\"hljs-string\">'戦士'</span>, <span class=\"hljs-number\">200</span>],\n    [<span class=\"hljs-string\">'魔法使い'</span>, <span class=\"hljs-number\">50</span>],\n    [<span class=\"hljs-string\">'勇者'</span>, <span class=\"hljs-number\">500</span>],\n    [<span class=\"hljs-string\">'戦士'</span>, <span class=\"hljs-number\">220</span>],\n    [<span class=\"hljs-string\">'商人'</span>, <span class=\"hljs-number\">120</span>],\n    [<span class=\"hljs-string\">'魔法使い'</span>, <span class=\"hljs-number\">70</span>]\n]\n</code></pre>\n<p>期待する出力は以下になります。</p>\n<pre><code class=\"hljs language-js\">[\n  [ <span class=\"hljs-string\">'魔法使い'</span>, <span class=\"hljs-number\">50</span> ],\n  [ <span class=\"hljs-string\">'魔法使い'</span>, <span class=\"hljs-number\">70</span> ],\n  [ <span class=\"hljs-string\">'戦士'</span>, <span class=\"hljs-number\">200</span> ],\n  [ <span class=\"hljs-string\">'戦士'</span>, <span class=\"hljs-number\">220</span> ],\n  [ <span class=\"hljs-string\">'商人'</span>, <span class=\"hljs-number\">120</span> ],\n  [ <span class=\"hljs-string\">'勇者'</span>, <span class=\"hljs-number\">500</span> ]\n]\n</code></pre>\n<p>もしくは逆でも良いですが。</p>\n<h2>sortメソッドで独自Expressionを与えよう</h2>\n<p>それでは、*Array.prototype.sort()*メソッドを用いて、独自のExpressionを書くことでソートをしていきましょう。</p>\n<p>メソッドの詳しい使い方はこちらを参照されたい。(多次元配列は詳しく書いていないので注意)<a href=\"https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\">MDNリファレンス</a>{:target=\"_blank\"}</p>\n<p>arrの要素のインデックス0番目を元にソートするコードはこちらです。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> arr = [\n    [<span class=\"hljs-string\">'戦士'</span>, <span class=\"hljs-number\">200</span>],\n    [<span class=\"hljs-string\">'魔法使い'</span>, <span class=\"hljs-number\">50</span>],\n    [<span class=\"hljs-string\">'勇者'</span>, <span class=\"hljs-number\">500</span>],\n    [<span class=\"hljs-string\">'戦士'</span>, <span class=\"hljs-number\">220</span>],\n    [<span class=\"hljs-string\">'商人'</span>, <span class=\"hljs-number\">120</span>],\n    [<span class=\"hljs-string\">'魔法使い'</span>, <span class=\"hljs-number\">70</span>]\n];\n\narr.<span class=\"hljs-title hljs-function\">sort</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =></span> {\n    <span class=\"hljs-keyword\">if</span> (a[<span class=\"hljs-number\">0</span>] > b[<span class=\"hljs-number\">0</span>]) <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (a[<span class=\"hljs-number\">0</span>] &#x3C; b[<span class=\"hljs-number\">0</span>]) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-number\">0</span>;\n});\n\n<span class=\"hljs-variable hljs-language\">console</span>.<span class=\"hljs-title hljs-function\">log</span>(arr)\n</code></pre>\n<p>これによって、先のセクションでお話しした通りの結果が返ってきます。</p>\n<p>うまくいった!!成功!!!!</p>\n<p>数値でやろうが手法は一切変わりません。実は。</p>\n<p>Array.prototype.sort()がどう動いていて、ソートをしているのか少し裏側が気になりますね。</p>\n<p>ちょっと興味あったら連絡をください。自分も興味あるので、少し調査して記事にするかもしれません。需要があれば記事にするのでTwitterより連絡ください。</p>\n</body>\n</html>\n","Title":"【JS】多次元配列を文字列に合わせてソートしたい!","Date":"2020-10-10","Category":"JavaScript","Tags":"JavaScript","Authors":"ゆうぼう","Slug":"sort-mularr-by-str","Thumbnail":"/images/thumbnails/js.png","Description":"一次元配列のソートは簡単だし、困るのは多次元配列です。しかも、よく記事になっているのは多次元配列の要素中の配列の数字に対してソートをよくやるんですよね〜。文字列でソートはどーやるん？と思って解決した方法を共有します。","Published":true},"categories":["Web","JavaScript","Competition","Cloud","Linux","Python","ML","Go","SQL"],"tags":["Apache","Appium","atmaCup","AWS","CentOS7","CentOS8","Colab","conda","CSS","ffmpeg","Flask","Go","Google Colaboratory","Heroku","HTML","JavaScript","JSON","Kaggle","Linux","Mac","make","map","MeCab","ML","MySQL","NLP","Node","node.js","npm","Pandas","Python","Pytorch","pytorch-lightning","Scikit-learn","Selenium","SISR","subprocess","Super-Resolution","tensorflow","Tkinter","zsh","オブジェクト指向","デコレータ","データ分析","特殊メソッド","超解像"]},"__N_SSG":true}
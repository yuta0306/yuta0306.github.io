{"pageProps":{"TaggedPostData":[{"contentHtml":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/katex@0.15.0/dist/katex.min.css\">\n</head>\n<body>\n<p>Pythonには<strong>デコレータ</strong>というものがあるのですが、意外と初学者には知られていない存在で比較的不思議な挙動をする感じがします。関数を直接的に実行しなくともファイルを読み込んだ段階で実行されるようなので、挙動について実験してみました。</p>\n<h2>デコレータ活用例</h2>\n<p>まずは、デコレータの活用例をお話しします。(Numpyから借用)</p>\n<p>Numpyにおいては、関数のモジュールを<em>numpy</em>に変更しており、override.pyか_override.pyだかに<em>set_module</em>関数が作られていたと思います(ちょっと曖昧)</p>\n<p>適当な関数を定義してモジュールを変更します。</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title hljs-function\">set_module</span>(<span class=\"hljs-params\">name</span>):\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title hljs-function\">decorator</span>(<span class=\"hljs-params\">func</span>):\n        func.__module__ = name\n        <span class=\"hljs-keyword\">return</span> func\n    <span class=\"hljs-keyword\">return</span> decorator\n    \n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title hljs-function\">check_module</span>(<span class=\"hljs-params\">func</span>):\n    <span class=\"hljs-built_in\">print</span>(func.__module__)\n    \n<span class=\"hljs-meta\">@set_module(<span class=\"hljs-params\"><span class=\"hljs-string\">'mylib'</span></span>)    </span><span class=\"hljs-comment\"># module名書き換え</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title hljs-function\">changed</span>():\n    <span class=\"hljs-keyword\">pass</span>\n    \n<span class=\"hljs-comment\"># module名変更なし</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title hljs-function\">not_changed</span>():\n    <span class=\"hljs-keyword\">pass</span>\n    \n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    check_module(changed)\n    check_module(not_changed)\n</code></pre>\n<p>各関数の役割</p>\n<ul>\n<li>set_module\n<ul>\n<li>デコレータ</li>\n<li>関数のモジュール名を変更する</li>\n</ul>\n</li>\n<li>changed\n<ul>\n<li>モジュール名を変更される関数</li>\n</ul>\n</li>\n<li>not_changed\n<ul>\n<li>モジュール名を<strong>変更されない</strong>関数</li>\n</ul>\n</li>\n</ul>\n<p>これらの実行結果が以下になります。</p>\n<pre><code class=\"hljs language-bash\">mylib\n__main__\n</code></pre>\n<p>変更された方は、期待した通りモジュール名が<em>mylib</em>に変わっていて、変更していない方はメインルーティンに入っていることになっています。</p>\n<h2>デコレータの挙動を追う</h2>\n<p>デコレータの挙動を追ってみます。基本的には動作がわかるように関数に機能はつけず、標準出力にて動作を確認していきます。</p>\n<p>実験するための関数を用意します。</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title hljs-function\">deco</span>(<span class=\"hljs-params\">name</span>):\n    <span class=\"hljs-built_in\">print</span>(name, <span class=\"hljs-string\">'開始'</span>)\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title hljs-function\">decorator</span>(<span class=\"hljs-params\">func</span>):\n        <span class=\"hljs-built_in\">print</span>(func.__name__, <span class=\"hljs-string\">'実行'</span>)\n        <span class=\"hljs-keyword\">return</span> func\n    <span class=\"hljs-built_in\">print</span>(name, <span class=\"hljs-string\">'終了'</span>)\n    <span class=\"hljs-keyword\">return</span> decorator\n    \n<span class=\"hljs-meta\">@deco(<span class=\"hljs-params\"><span class=\"hljs-string\">'deco1'</span></span>)</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title hljs-function\">test1</span>():\n    <span class=\"hljs-keyword\">pass</span>\n    \n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">\"__main__\"</span>:\n    <span class=\"hljs-keyword\">pass</span>\n</code></pre>\n<p>特別難しいこともありません。ただ各タイミングで出力を待つデコレータです。</p>\n<p>実行結果が以下になります。</p>\n<pre><code class=\"hljs language-bash\">deco1 開始\ndeco1 終了\ntest1 実行\n</code></pre>\n<p>デコレータの外の関数を動かした後、デコレートされた(装飾された)関数が返されるという感じです。</p>\n<p>流れは以下になります。</p>\n<ol>\n<li>デコレータの発火</li>\n<li>デコレータにより関数を装飾</li>\n<li>装飾された関数が返ってくる</li>\n<li>あとは3の関数を使うだけ</li>\n</ol>\n<p>このような流れになっていきます。デコレータは関数を装飾するものなので、ちょっと特殊であまり使うことがない気もしますが...</p>\n<p>また、<strong>メインルーティンで何も動かしていないのにもかかわらず</strong>、出力されています。</p>\n<p>デコレータは読み込んだときに動くようです。その特徴がわかればそこまでデコレータは難しいものでもなさそうです。</p>\n<p>あとでまた多重デコレータに関する話をしたいと思います。</p>\n</body>\n</html>\n","Title":"Pythonのデコレータの挙動を実験してみた","Date":"2020-10-26","Category":"Python","Tags":["Python","デコレータ"],"Authors":"ゆうぼう","Slug":"decorator-timing","Thumbnail":"/images/thumbnails/python.jpg","Description":"Pythonにはデコレータというものがあるのですが、意外と初学者には知られていない存在で比較的不思議な挙動をする感じがします。関数を直接的に実行しなくともファイルを読み込んだ段階で実行されるようなので、挙動について実験してみました。","Published":true}],"tag":"デコレータ","categories":["Web","JavaScript","Competition","Cloud","Linux","Python","ML","Go","SQL"],"tags":["Apache","Appium","atmaCup","AWS","CentOS7","CentOS8","Colab","conda","CSS","ffmpeg","Flask","Go","Google Colaboratory","Heroku","HTML","JavaScript","JSON","Kaggle","Linux","Mac","make","map","MeCab","ML","MySQL","NLP","node.js","Pandas","Python","Pytorch","pytorch-lightning","Scikit-learn","Selenium","SISR","subprocess","Super-Resolution","tensorflow","Tkinter","zsh","オブジェクト指向","デコレータ","データ分析","特殊メソッド","超解像"],"pages":1,"page":1},"__N_SSG":true}